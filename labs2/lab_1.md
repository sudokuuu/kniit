### **Лабораторная работа # 1: Многопоточность**
## **Задачи по многопоточности с `wait()` и `notify()`**

### **1.1 Задача «Автозаправочная станция»**
**Описание:**  
На автозаправочной станции **только 2 колонки**. Если все заняты, машины ждут в очереди.  
Когда колонка освобождается, следующий автомобиль из очереди начинает заправку.

**Что нужно реализовать?**  
- Использовать `wait()` и `notify()` для ожидания и освобождения заправки.  
- Поток **"Машина"** ждет, если все колонки заняты.  
- Поток **"Машина"** заправляется, затем освобождает колонку.

---

### **1.2 Задача «Ресторан: Повар и Официант»**
**Описание:**  
В ресторане работает один **повар** и один **официант**.
- **Повар** готовит блюда и ставит их на поднос (максимум 3 блюда).
- **Официант** берет готовые блюда и подает их клиентам.

**Что нужно реализовать?**  
- Повар не может готовить больше 3 блюд (ждет `wait()`).  
- Официант ждет, если поднос пуст (`wait()`).  
- При каждой передаче блюда используется `notify()`.

---

### **1.3 Задача «Производитель-Потребитель с ограничением»**
**Описание:**
- **Производитель** создает товары (максимум 5).
- **Потребитель** забирает товары.
- Если товаров **нет**, потребитель ждет (`wait()`).
- Если товаров **максимум**, производитель ждет (`wait()`).

**Что нужно реализовать?**  
- `wait()` – если товаров нет или склад заполнен.  
- `notify()` – пробуждение потока, когда изменяется состояние склада.

---

### **1.4 Задача «Перекресток: светофор и машины»**
**Описание:**  
На перекрестке светофор управляет движением:
- Красный свет – **машины стоят (`wait()`)**.
- Зеленый свет – **машины едут (`notifyAll()`)**.
- Светофор переключается каждые 5 секунд.

**Что нужно реализовать?**  
- Поток **"Светофор"** изменяет цвет и отправляет `notifyAll()`.  
- Потоки **"Машина"** ждут `wait()`, если красный свет.

---
### **1.5 Задача «Конвейер сборки деталей»**

#### **Описание задачи**
На заводе работают три типа рабочих, каждый из которых выполняет свою часть работы в **конвейерном режиме**:
1. **Штамповщик** – вырезает заготовку (создает объект детали).
2. **Сборщик** – собирает из заготовки готовую деталь.
3. **Оператор контроля качества** – проверяет деталь и отправляет на склад.

Каждый рабочий – **отдельный поток**, и они должны работать **последовательно**, используя общую очередь для передачи деталей.

#### **Требования к решению**
- Использовать **потоки** (`Thread` или `ExecutorService`).
- Использовать **синхронизацию** (`wait()`, `notify()`, `BlockingQueue`).
- Реализовать **конвейерную передачу данных** между потоками.

---

### **Пример работы программы**
```
Штамповщик: Заготовка 1 создана
Сборщик: Заготовка 1 обработана
Оператор контроля: Деталь 1 проверена и отправлена на склад
Штамповщик: Заготовка 2 создана
Сборщик: Заготовка 2 обработана
Оператор контроля: Деталь 2 проверена и отправлена на склад
...
```

---

### **Подсказки к решению**
- Использовать **`BlockingQueue`** для передачи деталей между рабочими.
- Штамповщик передает заготовку сборщику, а тот – оператору контроля.
- Потоки должны **ждать**, если предыдущий этап не завершен.

---


### **1.6 Задача «Гонка бегунов»**

#### **Описание**
Группа спортсменов участвует в забеге. Однако перед началом гонки все должны собраться на старте. Как только все участники будут готовы, забег начнётся одновременно. Используйте `CyclicBarrier`, чтобы синхронизировать запуск гонки.

Каждый бегун стартует одновременно, затем бежит разное время (симулируется `Thread.sleep`), после чего финиширует. Как только все бегуны завершат дистанцию, программа выводит сообщение о завершении гонки.

#### **Требования к задаче:**
1. Создать `CyclicBarrier` для синхронизации начала забега.
2. Реализовать класс `Runner`, который будет выполнять следующую логику в потоке:
    - Ожидание старта (использование `barrier.await()`).
    - Симуляция бега (`Thread.sleep(randomTime)`).
    - Вывод сообщения о финише.
3. После финиша всех участников программа должна сообщить, что гонка завершена.
4. Количество бегунов передаётся в аргументах командной строки или задаётся константой.

#### **Подсказка**
- Используйте `Executors.newFixedThreadPool()` для управления потоками.
- Для генерации случайного времени забега можно использовать `ThreadLocalRandom.current().nextInt(500, 3000)`.
